
## Annotation
### 元注解

|元注解|解释|        
|:----|:----|
|@Target|表示注解用于什么地方。可能的ElementType参数包括：CONSTRUCTOR: 构造器声明 FIELD: 域声明（包括enum实例），LOCAL_VARIABLE:局部变量声明，METHOD: 方法声明，PACKAGE：包声明。PARAMETER: 参数说明，TYPE: 类、接口（包括注解类型）或enum声明。|
|@Retention|表示需要在什么级别保存该注解信息。可选的RetentionPolicy参数包括：SOURCE: 注解将被编译器丢弃，CLASS:注解在class文件中可用，但会被VM丢掉，RUNTIME:VM在运行期也会保留注解，因此可以通过反射机制读取注解|
|@Documented|将此注解包含在Javadoc中|
|@Inherited|允许子类继承父类中的注解|

### 注解元素可用类型
* 所有基本类型(int,float,boolean)等
* String
* Class
* enum
* Annotation
* 以上类型的数组       

如果过你使用了其它类型，编译器会报错. 注意，也不能使用任何包装类,不过
由于自动打包的存在，这算不上什么限制。注解也可以作为元素类型，也就是说注解可以
嵌套,这是很有用的一个技巧.

### 默认值限制
* 元素不能有不确定的值，元素要么具有值，要么在使用时提供元素的值.
* 非基本类型的元素，注解接口中定义的值不能为null. 一般用空字符串，或负数来表示元素不存在.

### 注解不支持继承
* 不能使用关键字extends来继承@interface的注解.


### 访问者设计模式
一个访问者会遍历某个数据结构或一个对象的集合，对其中的每一个对象执行一个操作。该数据结构
无需有序，而你对每个对象执行的操作，都是特定于此对象的类型。这就将操作与对象解耦，也就是说，你可以添加新的操作，而无需向类的定义中添加方法.


## 并发

#### 基本的线程机制
并发编程使程序划分多个分离的、独立的运行的任务。通过多线程这些独立的任务中的每一由都将有执行线程来驱动。

一个线程就是在进程中的一个单一的顺序控制流,因此单个进程可以拥有多个并发执行的任务，但是你的
程序使得每个任务好像有其自己的cpu一样。其底层机制是切分cpu时间，但通常你不需要考虑它。
1. 时间片机制.
cpu轮流给每个任务分配时间片,使得人们看起来它们都在运行。
2. 


从Runnable导出一个类时，它必须具有run()方法，但是该方法并无特殊之处，它不会产生任何内在的线程能力。
要实现线程行为你必须将一个任务附着到线程上.

将一个Runnable对象转换为一个工作任务的传统方式就是把它交给一个**Thread()** 构造器。通过调用
Thread的start()方法来为该线程执行必须的初始化操作，start会立即返回，然后Runnable在调用run()方法，以便在
这个新线程中启动该任务.

***java.util.concurrency.Executors*** 执行器.         
* Executors 在客户端和执行任务之间提供了一个间接层；与客户端直接执行任务不同，这个中介任务将执行。       
* Executors 允许你管理异步任务的执行，而无需显示的管理线程的生命周期.     
* Executors 是启动任务的优选方法.

***ExecutorService***,（具有生命周期的Executor，例如关闭）知道如何构建恰当的上下文来执行Runnable对象。
```java
// 使用静态的Executor方法构建ExecutorService
ExecutorService exec = Executor.newCachedThreadPool();
```

#### Executor线程池静态方法   
在任何线程池中，现有线程在可能的情况下，都会被自动复用.

|method|description|
|:---|:---|
|newCachedThreadPool|将为每个任务创建一个线程,然后在它回收旧线程时停止创建新线程，因此它是合理的Executor首选,只有当这种方式会引发问题时，你才需要切换到FixedThreadPool|
|newFixedThreadPool(5)|使用有限线程集来执行所提交的任务,可以一次性预先执行代价高昂的线程分配,因而也就可以限制线程的数量。这对于你希望在另一个线程中连续运行的任何事物（长期存活的任务）来说，是很有用的|
|newSingleThreadPool|就像是FixedThreadPool(1)，它还提供了一种重要的并发机制，其它线程不会被并发调用。提交多个任务将排队，每个任务都会在下一个任务运行开始之前运行结束,所有任务都是用相同的线程.|

#### Thread 相关静态方法

|name|description|
|:---|:---|
|Thread.yield()|调用yield(),对线程调度器（java线程机制的一部分，可以将cpu从一个线程转移给另一个线程）的一种建议。 它在声明：我已经执行完生命周期中最重要的部分，此刻正是切换给其他任务执行的大好时机.|
